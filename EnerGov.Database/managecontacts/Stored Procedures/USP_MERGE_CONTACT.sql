--Moved from existing Scripts folder for new business framework  
CREATE PROCEDURE [managecontacts].[USP_MERGE_CONTACT]  
@USERID AS varchar(36),  
@MAINGUID AS varchar(36),  
@DELETE AS bit,  
@REPLACEGUIDS RECORDIDS READONLY  
AS

-- NOTE: If GLOBALENTITY table columns are changed, make sure to do similar change in MERGECONTACTARCHIVE table  

BEGIN  
  /*DROP TEMP TABLES IF THEY EXIST*/  
  IF OBJECT_ID('tempDB..#FKLIST', 'U') IS NOT NULL  
    DROP TABLE #FKLIST  
  IF OBJECT_ID('tempDB..#REFERENCETABLE', 'U') IS NOT NULL  
    DROP TABLE #REFERENCETABLE  
  IF OBJECT_ID('tempDB..#REPLACEGUIDS', 'U') IS NOT NULL  
    DROP TABLE #REPLACEGUIDS  
  IF OBJECT_ID('tempDB..#TABLECOLUMNLIST', 'U') IS NOT NULL  
    DROP TABLE #TABLECOLUMNLIST  
  IF OBJECT_ID('tempDB..#MERGECONTACTHISTORYTEMP', 'U') IS NOT NULL  
    DROP TABLE #MERGECONTACTHISTORYTEMP  
  IF OBJECT_ID('tempDB..#MERGEHISTORYQUEUE', 'U') IS NOT NULL  
    DROP TABLE #MERGEHISTORYQUEUE  
  
  SET NOCOUNT ON  
  CREATE TABLE #REPLACEGUIDS (  
    GLOBALENTITYID varchar(36)  
  )  
  INSERT INTO #REPLACEGUIDS  
    SELECT  
      RECORDID  
    FROM @REPLACEGUIDS  
  
  /*THIS DYNAMICALLY BUILDS A LIST OF ALL FOREIGN KEYS TO GLOBAL ENTITY*/  
  CREATE TABLE #FKLIST (  
    PKTABLE_QUALIFIER varchar(150),  
    PKTABLE_OWNER varchar(150),  
    PKTABLE_NAME varchar(150),  
    PKCOLUMN_NAME varchar(150),  
    FKTABLE_QUALIFIER varchar(150),  
    FKTABLE_OWNER varchar(150),  
    FKTABLE_NAME varchar(150),  
    FKCOLUMN_NAME varchar(150),  
    KEY_SEQ binary,  
    UPDATE_RULE binary,  
    DELETE_RULE binary,  
    FK_NAME varchar(150),  
    PK_NAME varchar(150),  
    DEFERRABILITY int  
  )  
  INSERT INTO #FKLIST  
  EXEC SP_FKEYS 'GLOBALENTITY'  
  
  /* ENERGOVWEB-2468 - For now, stop moving old contact addresses to the contact you've kept.  If they are deleted, so are their addresses. */  
  DELETE FROM #FKLIST  
  WHERE #FKLIST.FKTABLE_NAME = 'GLOBALENTITYMAILINGADDRESS'  
  
  CREATE TABLE #TABLECOLUMNLIST (  
    FKTABLE_NAME varchar(150),  
    FKCOLUMN_NAME varchar(150),  
    HISTORYTABLE varchar(150),  
    HISTORYCOLUMN varchar(150),  
    PARENTTABLE varchar(150),  
    REFERENCETABLE varchar(150),  
    FULLCLASSNAME varchar(150)  
  )  
  CREATE TABLE #MERGECONTACTHISTORYTEMP (  
    MERGECONTACTHISTORYID char(36),  
    TABLEUPDATED varchar(150),  
    COLUMNUPDATED varchar(150),  
    COLUMNLINK varchar(150),  
    RECORDID varchar(36),  
    OLD_ID varchar(36),  
    NEW_ID varchar(36)  
  )  
  
  INSERT INTO #TABLECOLUMNLIST  
    SELECT  
      F.FKTABLE_NAME,  
      F.FKCOLUMN_NAME,  
      R.HISTORYTABLE,  
      R.HISTORYCOLUMN,  
      R.PARENTTABLE,  
      R.REFERENCETABLE,  
      R.FULLCLASSNAME  
    FROM #FKLIST F  
    LEFT JOIN [dbo].[MERGECONTACTREFERENCE] R   
      ON F.FKTABLE_NAME = R.[REFERENCETABLE]  
  
  CREATE INDEX TEMP1 ON #TABLECOLUMNLIST (REFERENCETABLE)  
  
  /*START TRY/CATCH TO HANDLE ERRORS*/  
  
  BEGIN TRY  
  
    /*START A TRANSACTION SO IT CAN ROLLBACK ON AN ERROR*/  
    SET TRANSACTION ISOLATION LEVEL READ COMMITTED  
    BEGIN TRANSACTION  
      /*INSERT INTO MERGECONTACTHISTORYTEMP.  THIS BUILDS A TABLE OF ALL CHANGES NEEDED*/  
      DECLARE MERGE_CURSOR CURSOR FOR  
      SELECT  
        TB.FKTABLE_NAME,  
        TB.FKCOLUMN_NAME,  
        TB.COLUMN_LINK,  
        R.GLOBALENTITYID  
      FROM (SELECT  
        FKTABLE_NAME,  
        FKCOLUMN_NAME,  
        CASE #FKLIST.FKTABLE_NAME  
          WHEN 'BCONLINE' THEN 'BCONLINELICENSENUM'  
          WHEN 'BLGLOBALENTITYEXTENSIONCONTACT' THEN 'BLGLOBALENTITYEXTCONTACTID'  
          WHEN 'COLICENSECERTIFICATION' THEN 'COSIMPLELICCERTID'  
          WHEN 'GLOBALENTITYGLOBALENTITYTYPE' THEN 'GLOBALENTITYTYPEID'  
          /* ENERGOVWEB-2468 - For now, stop moving old contact addresses to the contact you've kept.  If they are deleted, so are their addresses. */  
          --WHEN 'GLOBALENTITYMAILINGADDRESS' THEN 'MAILINGADDRESSID'  
          WHEN 'SIGNATUREHISTORY' THEN 'SIGNATUREID'  
          WHEN 'USERFAVORITECONTACTS' THEN 'USERID'  
          WHEN 'USERS' THEN 'SUSERGUID'  
          ELSE #FKLIST.FKTABLE_NAME + 'ID'  
        END AS COLUMN_LINK  
      FROM #FKLIST  
      /*********************************************************  
   **UNION SPECIAL CASE FIELDS NOT HANDLED BY A FOREIGN KEY**  
   **********************************************************/  
      UNION ALL  
      SELECT  
        [MERGECONTACTMISSINGFKEYS].[FKEYTABLE],  
        [MERGECONTACTMISSINGFKEYS].[FKEYCOLUMN],  
        [MERGECONTACTMISSINGFKEYS].[REFERENCECOLUMN]  
      FROM [dbo].[MERGECONTACTMISSINGFKEYS]) TB  
      CROSS JOIN #REPLACEGUIDS R  
  
      OPEN MERGE_CURSOR  
  
      DECLARE @LOOPTABLENAME varchar(150)  
      DECLARE @LOOPFIELDNAME varchar(150)  
      DECLARE @LOOPCOLUMNLINK varchar(150)  
      DECLARE @LOOPGLOBALENTITY varchar(36)  
  
      FETCH NEXT FROM MERGE_CURSOR  
      INTO @LOOPTABLENAME, @LOOPFIELDNAME, @LOOPCOLUMNLINK, @LOOPGLOBALENTITY  
  
      DECLARE @MERGEQUESQL AS nvarchar(max)  
      WHILE @@FETCH_STATUS = 0  
      BEGIN  
        SET @MERGEQUESQL =  
  
  
        'INSERT INTO #MERGECONTACTHISTORYTEMP SELECT NEWID(), ''' + @LOOPTABLENAME +  
        ''', ''' + @LOOPCOLUMNLINK +  
        ''', ''' + @LOOPFIELDNAME +  
        ''', ' + @LOOPCOLUMNLINK +  
        ', ' + @LOOPFIELDNAME +  
        ', ''' + @MAINGUID +  
        ''' FROM ' + @LOOPTABLENAME +  
        ' WHERE ' + @LOOPFIELDNAME +  
        ' = ''' + @LOOPGLOBALENTITY + ''''  
  
        EXEC (@MERGEQUESQL)  
  
        FETCH NEXT FROM MERGE_CURSOR  
        INTO @LOOPTABLENAME, @LOOPFIELDNAME, @LOOPCOLUMNLINK, @LOOPGLOBALENTITY  
      END  
  
      CLOSE MERGE_CURSOR  
      DEALLOCATE MERGE_CURSOR  
  
      PRINT 'TEMP MERGE HISTORY TABLE CREATED AND FILLED'  
        
		--Delete entries from GLOBALENTITYSUBCONTACTXREF before update to handle merge contact with contacts having mutual parent or child contacts
		DELETE NEWTABLE FROM [dbo].[GLOBALENTITYSUBCONTACTXREF] NEWTABLE INNER JOIN #MERGECONTACTHISTORYTEMP MERGETABLE 
		ON NEWTABLE.PARENTGLOBALENTITYID =  MERGETABLE.NEW_ID
		INNER JOIN [dbo].[GLOBALENTITYSUBCONTACTXREF] OLDTABLE 
		ON OLDTABLE.GLOBALENTITYSUBCONTACTXREFID = MERGETABLE.RECORDID
		WHERE MERGETABLE.TABLEUPDATED = 'GLOBALENTITYSUBCONTACTXREF' AND MERGETABLE.COLUMNLINK = 'PARENTGLOBALENTITYID'
		AND NEWTABLE.SUBCONTACTGLOBALENTITYID = OLDTABLE.SUBCONTACTGLOBALENTITYID

		DELETE NEWTABLE FROM [dbo].[GLOBALENTITYSUBCONTACTXREF] NEWTABLE INNER JOIN #MERGECONTACTHISTORYTEMP MERGETABLE 
		ON NEWTABLE.SUBCONTACTGLOBALENTITYID =  MERGETABLE.NEW_ID
		INNER JOIN [dbo].[GLOBALENTITYSUBCONTACTXREF] OLDTABLE 
		ON OLDTABLE.GLOBALENTITYSUBCONTACTXREFID = MERGETABLE.RECORDID
		WHERE MERGETABLE.TABLEUPDATED = 'GLOBALENTITYSUBCONTACTXREF' AND MERGETABLE.COLUMNLINK = 'SUBCONTACTGLOBALENTITYID'
		AND NEWTABLE.PARENTGLOBALENTITYID = OLDTABLE.PARENTGLOBALENTITYID
  
	/*UPDATE RECORDS BASED ON MERGE HISTORY QUEUE.  THIS USES MERGECONTACTHISTORYTEMP TO RUN LINE BY LINE UPDATES*/
      DECLARE UPDATE_CURSOR CURSOR FOR  
  
      SELECT  
        M.TABLEUPDATED,  
        M.COLUMNUPDATED,  
        M.COLUMNLINK,  
        M.RECORDID,  
        M.NEW_ID  
      FROM #MERGECONTACTHISTORYTEMP M  
      WHERE M.TABLEUPDATED NOT IN ('GLOBALENTITYGLOBALENTITYTYPE', 'USERFAVORITECONTACTS', 'GLOBALENTITYHOLD') /*EXCLUDE TABLES COVERED BY SPECIFIC CODE BELOW*/  
  
      OPEN UPDATE_CURSOR  
  
      DECLARE @LOOPTABLEUPDATED varchar(150)  
      DECLARE @LOOPCOLUMNNAME varchar(150)  
      DECLARE @LOOPCOLUMNLINK2 varchar(150)  
      DECLARE @LOOPRECORDID varchar(150)  
      DECLARE @LOOPNEWID varchar(36)  
  
      FETCH NEXT FROM UPDATE_CURSOR  
      INTO @LOOPTABLEUPDATED, @LOOPCOLUMNNAME, @LOOPCOLUMNLINK2, @LOOPRECORDID, @LOOPNEWID  
  
      DECLARE @UPDATESQL AS nvarchar(max)  
      WHILE @@FETCH_STATUS = 0  
      BEGIN  
        SET @UPDATESQL =  
  
        'UPDATE ' + @LOOPTABLEUPDATED +  
        ' SET ' + @LOOPCOLUMNLINK2 +  
        ' = N''' + @LOOPNEWID +  
        ''' WHERE ' + @LOOPCOLUMNNAME +  
        ' = ''' + @LOOPRECORDID + ''''  
  
        EXEC (@UPDATESQL)  
  
        FETCH NEXT FROM UPDATE_CURSOR  
        INTO @LOOPTABLEUPDATED, @LOOPCOLUMNNAME, @LOOPCOLUMNLINK2, @LOOPRECORDID, @LOOPNEWID  
      END  
  
      CLOSE UPDATE_CURSOR  
      DEALLOCATE UPDATE_CURSOR  
  
      /*****************************************************************  
   **SPECIFIC QUERIES TO UPDATE TABLES THAT FALL OUTSIDE THE CURSOR**  
   ******************************************************************/  
      /*GLOBALENTITYHOLD*/  
      DECLARE @ORIGINNUMBER varchar(150)  
      SET @ORIGINNUMBER = (SELECT  
        CASE  
          WHEN ISCOMPANY = 1 THEN RTRIM(GLOBALENTITYNAME)  
          ELSE RTRIM(GLOBALENTITY.LASTNAME) + ', ' + RTRIM(GLOBALENTITY.FIRSTNAME)  
        END  
      FROM GLOBALENTITY  
      WHERE GLOBALENTITYID = @MAINGUID)  
  
      UPDATE GLOBALENTITYHOLD  
      SET GLOBALENTITYID = @MAINGUID,  
          ORIGIN = @MAINGUID,  
          ORIGINNUMBER = @ORIGINNUMBER  
      FROM GLOBALENTITYHOLD contact  
      WHERE contact.GLOBALENTITYID IN (SELECT  
        OLD_ID  
      FROM #MERGECONTACTHISTORYTEMP M  
      WHERE M.TABLEUPDATED = 'GLOBALENTITYHOLD')  
  
  
      /*GLOBALENTITYGLOBALENTITYTYPE*/  
  
      DELETE GLOBALENTITYGLOBALENTITYTYPE  
        FROM GLOBALENTITYGLOBALENTITYTYPE  
        INNER JOIN #MERGECONTACTHISTORYTEMP M  
          ON M.RECORDID = GLOBALENTITYGLOBALENTITYTYPE.GLOBALENTITYTYPEID  
          AND M.OLD_ID = GLOBALENTITYGLOBALENTITYTYPE.GLOBALENTITYID  
      WHERE M.TABLEUPDATED = 'GLOBALENTITYGLOBALENTITYTYPE';  
  
      INSERT INTO GLOBALENTITYGLOBALENTITYTYPE (GLOBALENTITYTYPEID,  
      GLOBALENTITYID)  
        SELECT  
          M.RECORDID,  
          M.NEW_ID  
        FROM #MERGECONTACTHISTORYTEMP M  
        WHERE M.TABLEUPDATED = 'GLOBALENTITYGLOBALENTITYTYPE'  
        AND M.RECORDID NOT IN (SELECT  
          G.GLOBALENTITYTYPEID  
        FROM #MERGECONTACTHISTORYTEMP M  
        INNER JOIN GLOBALENTITYGLOBALENTITYTYPE G  
          ON M.RECORDID = G.GLOBALENTITYTYPEID  
          AND M.NEW_ID = G.GLOBALENTITYID  
        WHERE M.TABLEUPDATED = 'GLOBALENTITYGLOBALENTITYTYPE')  
  
      /*USERFAVORITECONTACTS*/  
  
      DELETE USERFAVORITECONTACTS  
        FROM USERFAVORITECONTACTS  
        INNER JOIN #MERGECONTACTHISTORYTEMP M  
          ON M.RECORDID = USERFAVORITECONTACTS.USERID  
          AND M.OLD_ID = USERFAVORITECONTACTS.GLOBALENTITYID  
      WHERE M.TABLEUPDATED = 'USERFAVORITECONTACTS';  
  
      INSERT INTO USERFAVORITECONTACTS (USERID,  
      GLOBALENTITYID)  
        SELECT  
          M.RECORDID,  
          M.NEW_ID  
        FROM #MERGECONTACTHISTORYTEMP M  
        WHERE M.TABLEUPDATED = 'USERFAVORITECONTACTS'  
        AND M.RECORDID NOT IN (SELECT  
          U.USERID  
        FROM #MERGECONTACTHISTORYTEMP M  
        INNER JOIN USERFAVORITECONTACTS U  
          ON M.RECORDID = U.USERID  
          AND M.NEW_ID = U.GLOBALENTITYID  
        WHERE M.TABLEUPDATED = 'USERFAVORITECONTACTS')  
  
      PRINT 'LINKED RECORDS MERGED'  
  
      /*CREATE HISTORY REFERENCE TABLE.  THIS WILL BE USED TO ADD HISTORY TO PARENT RECORDS*/  
      CREATE TABLE #MERGEHISTORYQUEUE (  
        MERGEHISTORYQUEUEID varchar(36),  
        FKTABLE_NAME varchar(150),  
        FKCOLUMN_NAME varchar(150),  
        HISTORYTABLE varchar(150),  
        HISTORYCOLUMN varchar(150),  
        RECORDID varchar(36),  
        RECORDCOLUMN varchar(150),  
        OLD_NAME varchar(250),  
        OLD_ID varchar(36),  
        NEW_NAME varchar(250),  
        NEW_ID varchar(36),  
        PARENTTABLE varchar(150),  
        FULLCLASSNAME varchar(150),  
        PARENTRECORDID varchar(36)  
      )  
      INSERT INTO #MERGEHISTORYQUEUE  
  
        SELECT  
          NEWID(),  
          T.FKTABLE_NAME,  
          T.FKCOLUMN_NAME,  
          T.HISTORYTABLE,  
          T.HISTORYCOLUMN,  
          M.RECORDID,  
          CASE T.FKTABLE_NAME  
            WHEN 'BCONLINE' THEN 'BCONLINELICENSENUM'  
            WHEN 'BLGLOBALENTITYEXTENSIONCONTACT' THEN 'BLGLOBALENTITYEXTCONTACTID'  
            WHEN 'COLICENSECERTIFICATION' THEN 'COSIMPLELICCERTID'  
            WHEN 'GLOBALENTITYGLOBALENTITYTYPE' THEN 'GLOBALENTITYTYPEID'  
            /* ENERGOVWEB-2468 - For now, stop moving old contact addresses to the contact you've kept.  If they are deleted, so are their addresses. */  
            --WHEN 'GLOBALENTITYMAILINGADDRESS' THEN 'MAILINGADDRESSID'  
            WHEN 'SIGNATUREHISTORY' THEN 'SIGNATUREID'  
            WHEN 'USERFAVORITECONTACTS' THEN 'USERID'  
            WHEN 'USERS' THEN 'SUSERGUID'  
            ELSE T.FKTABLE_NAME + 'ID'  
          END AS RECORDCOLUMN,  
          REPLACE(RTRIM(RTRIM(ISNULL(O.FIRSTNAME, '') + ' ' + ISNULL(O.LASTNAME, '')) + ' ' + ISNULL(O.GLOBALENTITYNAME, '')), '''', '') OLDNAME,  
          O.CONTACTID,  
          REPLACE(RTRIM(RTRIM(ISNULL(N.FIRSTNAME, '') + ' ' + ISNULL(N.LASTNAME, '')) + ' ' + ISNULL(N.GLOBALENTITYNAME, '')), '''', '') NEWNAME,  
          N.CONTACTID,  
          T.PARENTTABLE,  
          T.FULLCLASSNAME,  
          NULL  
        FROM #TABLECOLUMNLIST T  
        INNER JOIN #MERGECONTACTHISTORYTEMP M  
          ON T.FKTABLE_NAME = M.TABLEUPDATED  
          INNER JOIN GLOBALENTITY O  
            ON M.OLD_ID = O.GLOBALENTITYID  
          INNER JOIN GLOBALENTITY N  
       ON M.NEW_ID = N.GLOBALENTITYID  
        WHERE T.HISTORYTABLE IS NOT NULL  
  
      CREATE INDEX TEMP2 ON #MERGEHISTORYQUEUE (RECORDID)  
  
      PRINT 'TEMP HISTORY TABLE BUILT AND POPULATED'  
  
      /*WRITE HISTORY*/  
      DECLARE HISTORY_CURSOR CURSOR FOR  
      SELECT  
        MERGEHISTORYQUEUEID,  
        FKTABLE_NAME,  
        HISTORYTABLE,  
        HISTORYCOLUMN,  
        RECORDID,  
        RECORDCOLUMN,  
        OLD_NAME,  
        OLD_ID,  
        NEW_NAME,  
        NEW_ID,  
        @USERID,  
        PARENTTABLE  
      FROM #MERGEHISTORYQUEUE  
  
      OPEN HISTORY_CURSOR  
      DECLARE @FKTABLE_NAME varchar(150)  
      DECLARE @HISTORYTABLE varchar(150)  
      DECLARE @HISTORYCOLUMN varchar(150)  
      DECLARE @RECORDID varchar(36)  
      DECLARE @RECORDCOLUMN varchar(150)  
      DECLARE @OLD_NAME varchar(250)  
      DECLARE @OLD_ID varchar(36)  
      DECLARE @NEW_NAME varchar(250)  
      DECLARE @NEW_ID varchar(36)  
      DECLARE @SUSERID varchar(36)  
      DECLARE @PARENTTABLE varchar(150)  
      DECLARE @PARENTRECORDID varchar(36)  
      DECLARE @QUEUEID varchar(36)  
  
      FETCH NEXT FROM HISTORY_CURSOR  
      INTO @QUEUEID, @FKTABLE_NAME, @HISTORYTABLE, @HISTORYCOLUMN, @RECORDID, @RECORDCOLUMN, @OLD_NAME, @OLD_ID, @NEW_NAME, @NEW_ID, @SUSERID, @PARENTTABLE  
  
      DECLARE @HISTORYSQL AS varchar(max)  
      DECLARE @ROWVERSIONSQL AS varchar(max)  
      DECLARE @UPDATEPARENTIDSQL AS varchar(max)  
      WHILE @@FETCH_STATUS = 0  
      BEGIN  
  
        SET @HISTORYSQL =  
        'INSERT INTO [' + @HISTORYTABLE +  
        '] ([ID], [RowVersion], [ChangedOn], [ChangedBy], [FieldName], [OldValue], [NewValue], [AdditionalInfo]) VALUES (' +  
        '(SELECT [' + @HISTORYCOLUMN + '] FROM [' + @FKTABLE_NAME + '] WHERE [' + @RECORDCOLUMN + '] = ''' + @RECORDID + ''')' +  
        ', 1' +  
        ', GETDATE()' +  
        ', ''' + @SUSERID +  
        ''', ''Contact Merged''' +  
        ', ''' + @OLD_ID + ' ' + @OLD_NAME +  
        ''', ''' + @NEW_ID + ' ' + @NEW_NAME +  
        ''', ''Contact Merged'')'  
  
        EXEC (@HISTORYSQL)  
  
        /*INCREMENT ROW VERSION IF EXISTS*/  
  
        SET @ROWVERSIONSQL =  
        'IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.COLUMNS I WHERE I.TABLE_NAME = ''' + @PARENTTABLE + ''' AND I.COLUMN_NAME = ''ROWVERSION'')  
       UPDATE [' + @PARENTTABLE + ']  
       SET ROWVERSION = (SELECT ROWVERSION FROM [' + @PARENTTABLE + '] WHERE [' + @HISTORYCOLUMN + '] = ' +  
        '(SELECT [' + @HISTORYCOLUMN + '] FROM [' + @FKTABLE_NAME + '] WHERE [' + @RECORDCOLUMN + '] = ''' + @RECORDID + ''')' + ') + 1  
       WHERE [' + @HISTORYCOLUMN + '] = ' +  
        '(SELECT [' + @HISTORYCOLUMN + '] FROM [' + @FKTABLE_NAME + '] WHERE [' + @RECORDCOLUMN + '] = ''' + @RECORDID + ''')' + ''  
  
        EXEC (@ROWVERSIONSQL)  
  
        /* UPDATE PARENTRECORDID */  
        IF @HISTORYCOLUMN IS NOT NULL  
        BEGIN  
          SET @UPDATEPARENTIDSQL = 'UPDATE #MERGEHISTORYQUEUE SET PARENTRECORDID = ' + '(SELECT [' + @HISTORYCOLUMN + '] FROM [' + @FKTABLE_NAME + '] WHERE [' + @RECORDCOLUMN + '] = ''' + @RECORDID + ''')' +  
          'WHERE MERGEHISTORYQUEUEID = ''' + @QUEUEID + ''''  
          --select @UPDATEPARENTIDSQL  
          EXEC (@UPDATEPARENTIDSQL)  
        END  
  
        FETCH NEXT FROM HISTORY_CURSOR  
        INTO @QUEUEID, @FKTABLE_NAME, @HISTORYTABLE, @HISTORYCOLUMN, @RECORDID, @RECORDCOLUMN, @OLD_NAME, @OLD_ID, @NEW_NAME, @NEW_ID, @SUSERID, @PARENTTABLE  
      END  
  
      CLOSE HISTORY_CURSOR  
      DEALLOCATE HISTORY_CURSOR  
  
      PRINT 'HISTORY TABLES WRITTEN TO'  
  
      /*MOVE TEMP MERGE HISTORY TO MERGECONTACTHISTORY*/  
      INSERT INTO MERGECONTACTHISTORY  
        SELECT  
          M.MERGECONTACTHISTORYID,  
          M.TABLEUPDATED,  
          M.RECORDID,  
          M.OLD_ID,  
          M.NEW_ID  
        FROM #MERGECONTACTHISTORYTEMP M  
  
      PRINT 'CURRENT MERGE HISTORY ADDED TO MERGE CONTACT HISTORY TABLE'  
  
  
      /*ADD HISTORY FOR MAIN CONTACT*/  
      INSERT INTO HISTORYSYSTEMSETUP (ID, ROWVERSION, CHANGEDON, CHANGEDBY, FIELDNAME, OLDVALUE, NEWVALUE, ADDITIONALINFO)  
        VALUES (@MAINGUID, 1, GETDATE(), @USERID, N'Contacts Merged', N'', N'', N'The following contact(s) merged into this contact: ' + ISNULL(STUFF((SELECT ', ' + GE.CONTACTID + ' ' + CASE WHEN GE.ISCONTACT = 1 THEN GE.FIRSTNAME + ' ' + GE.LASTNAME ELSE
 GE.GLOBALENTITYNAME END FROM #REPLACEGUIDS R INNER JOIN GLOBALENTITY GE ON R.GLOBALENTITYID = GE.GLOBALENTITYID FOR xml PATH (''), ROOT ('MyString'), TYPE).value('/MyString[1]', 'varchar(max)'), 1, 2, ''), ''))  
  
      PRINT 'MAIN CONTACT HISTORY WRITTEN'  
  
  
      /*ADD HISTORY FOR DE-ACTIVATED CONTACTS*/  
      DECLARE @MAINCONTACTNAME varchar(1000)  
      SET @MAINCONTACTNAME = (SELECT  
        CONTACTID + ' ' + CASE  
          WHEN ISCONTACT = 1 THEN FIRSTNAME + ' ' + LASTNAME  
          ELSE GLOBALENTITYNAME  
        END  
      FROM GLOBALENTITY  
      WHERE GLOBALENTITYID = @MAINGUID)  
  
      INSERT INTO HISTORYSYSTEMSETUP (ID, ROWVERSION, CHANGEDON, CHANGEDBY, FIELDNAME, OLDVALUE, NEWVALUE, ADDITIONALINFO)  
        SELECT  
          RPGS.GLOBALENTITYID,  
          ge.ROWVERSION,  
          GETDATE(),  
          @USERID,  
          N'Contact Active Flag',  
          CASE  
            WHEN (SELECT TOP 1  
                NEWVALUE  
              FROM HISTORYSYSTEMSETUP  
              WHERE ID = RPGS.GLOBALENTITYID  
              ORDER BY CHANGEDON DESC)  
              = '' THEN N'True'  
            ELSE ISNULL((SELECT TOP 1  
                NEWVALUE  
              FROM HISTORYSYSTEMSETUP  
              WHERE ID = RPGS.GLOBALENTITYID  
              ORDER BY CHANGEDON DESC), N'True')  
          END,  
          N'False',  
          N'Contact de-activated due to being merged into ' + @MAINCONTACTNAME  
        FROM #REPLACEGUIDS RPGS  
        JOIN GLOBALENTITY GE  
          ON RPGS.GLOBALENTITYID = GE.GLOBALENTITYID  
  
  
      PRINT 'DE-ACTIVATED CONTACTS HISTORY WRITTEN'  
  
      /*DELETE OR INACTIVATE GLOBAL ENTITY RECORDS*/  
  
      IF (@DELETE = 1)  
      BEGIN  
        INSERT INTO [dbo].[MERGECONTACTARCHIVE]  (GLOBALENTITYID,PARENTGLOBALENTITYID,GLOBALENTITYNAME,ISCOMPANY,ISCONTACT,
        MANUFACTURER,VENDOR,SHIPPER,EMAIL,WEBSITE,BUSINESSPHONE,HOMEPHONE,MOBILEPHONE,OTHERPHONE,FAX,IMAGE,FIRSTNAME,LASTNAME,
        MIDDLENAME,TITLE,LASTCHANGEDON,LASTCHANGEDBY,ROWVERSION,IMPNAMEKEY,IMPADDKEY,NAME1,NAME2,CONTACTID,PREFCOMM,ISACTIVE,OTHEREMAIL)
          SELECT  
            GLOBALENTITY.GLOBALENTITYID,GLOBALENTITY.PARENTGLOBALENTITYID,GLOBALENTITY.GLOBALENTITYNAME,GLOBALENTITY.ISCOMPANY,
            GLOBALENTITY.ISCONTACT,GLOBALENTITY.MANUFACTURER,GLOBALENTITY.VENDOR,GLOBALENTITY.SHIPPER,GLOBALENTITY.EMAIL,GLOBALENTITY.WEBSITE,GLOBALENTITY.BUSINESSPHONE,
            GLOBALENTITY.HOMEPHONE,GLOBALENTITY.MOBILEPHONE,GLOBALENTITY.OTHERPHONE,GLOBALENTITY.FAX,GLOBALENTITY.IMAGE,GLOBALENTITY.FIRSTNAME,
            GLOBALENTITY.LASTNAME,GLOBALENTITY.MIDDLENAME,GLOBALENTITY.TITLE,GLOBALENTITY.LASTCHANGEDON,GLOBALENTITY.LASTCHANGEDBY,GLOBALENTITY.ROWVERSION,
            GLOBALENTITY.IMPNAMEKEY,GLOBALENTITY.IMPADDKEY,GLOBALENTITY.NAME1,GLOBALENTITY.NAME2,GLOBALENTITY.CONTACTID,GLOBALENTITY.PREFCOMM,
            GLOBALENTITY.ISACTIVE,GLOBALENTITY.OTHEREMAIL  
          FROM GLOBALENTITY  
          INNER JOIN #REPLACEGUIDS R  
            ON R.GLOBALENTITYID = GLOBALENTITY.GLOBALENTITYID  
        /* ENERGOVWEB-2468 - For now, stop moving old contact addresses to the contact you've kept.  If they are deleted, so are their addresses. */  
        DELETE FROM GLOBALENTITYMAILINGADDRESS  
        WHERE GLOBALENTITYMAILINGADDRESS.GLOBALENTITYID IN (SELECT  
            R.GLOBALENTITYID  
          FROM #REPLACEGUIDS R)  
        DELETE FROM GLOBALENTITY  
        WHERE GLOBALENTITY.GLOBALENTITYID IN (SELECT  
            R.GLOBALENTITYID  
          FROM #REPLACEGUIDS R)  
        PRINT 'MERGED CONTACTS ARCHIVED'  
      END  
      ELSE  
      BEGIN  
        DECLARE DELETE_CURSOR CURSOR FOR  
        SELECT  
          GLOBALENTITYID  
        FROM #REPLACEGUIDS R  
  
        OPEN DELETE_CURSOR  
        DECLARE @DELETEGLOBALENTITYID varchar(36)  
  
        FETCH NEXT FROM DELETE_CURSOR  
        INTO @DELETEGLOBALENTITYID  
  
        DECLARE @DELETESQL AS varchar(max)  
        WHILE @@FETCH_STATUS = 0  
        BEGIN  
  
          SET @DELETESQL =  
          'UPDATE GLOBALENTITY SET GLOBALENTITY.ISACTIVE = 0 WHERE GLOBALENTITY.GLOBALENTITYID = '''  
          + @DELETEGLOBALENTITYID + ''''  
  
          PRINT @DELETESQL;  
          EXEC (@DELETESQL)  
  
  
          FETCH NEXT FROM DELETE_CURSOR  
          INTO @DELETEGLOBALENTITYID  
        END  
  
        CLOSE DELETE_CURSOR  
        DEALLOCATE DELETE_CURSOR  
        PRINT 'MERGED CONTACTS SET TO INACTIVE'  
      END  
  
      /*INSERT CHANGES INTO TABLE TO UPDATE ELASTIC SEARCH*/  
  
      DECLARE @SERVICEBUSTENANT varchar(50)  
      SET @SERVICEBUSTENANT = (SELECT TOP 1  
        S.STRINGVALUE  
      FROM SETTINGS S  
      WHERE S.[NAME] = 'ServiceBusTenant')  
  
      INSERT INTO ELASTICSEARCHOBJECT (ELASTICSEARCHOBJECTID,  
      OBJECTID,  
      OBJECTCLASSNAME,  
      ROWVERSION,  
      CREATEDATE,  
      PROCESSEDDATE,  
      OBJECTACTION,  
      INDEXNAME)  
  
        SELECT  
          TB.ELASTICSEARCHOBJECTID,  
          TB.OBJECTID,  
          TB.OBJECTCLASSNAME,  
          TB.[ROWVERSION],  
          TB.CREATEDATE,  
          TB.PROCESSEDDATE,  
          TB.OBJECTACTION,  
          TB.INDEXNAME  
        FROM (  
        /*FIRST PLACE THE UPDATING GLOBAL ENTITIES INTO THE TABLE*/  
        SELECT  
          NEWID() AS ELASTICSEARCHOBJECTID,  
          R.GLOBALENTITYID AS OBJECTID,  
          N'EnerGovBusiness.SystemSetup.GlobalEntity' AS OBJECTCLASSNAME,  
          0 AS 'ROWVERSION',  
          GETDATE() AS 'CREATEDATE',  
          NULL AS 'PROCESSEDDATE',  
          CASE  
            WHEN @DELETE = 1 THEN 3  
            ELSE 2  
          END AS OBJECTACTION,  
          @SERVICEBUSTENANT AS INDEXNAME  
        FROM #REPLACEGUIDS R  
        UNION ALL  
        SELECT  
          NEWID() AS ELASTICSEARCHOBJECTID,  
          M.PARENTRECORDID AS OBJECTID,  
          M.FULLCLASSNAME AS OBJECTCLASSNAME,  
          0 AS 'ROWVERSION',  
          GETDATE() AS 'CREATEDATE',  
          NULL AS 'PROCESSEDDATE',  
          2 AS OBJECTACTION,  
          @SERVICEBUSTENANT AS INDEXNAME  
        FROM #MERGEHISTORYQUEUE M  
        WHERE M.FULLCLASSNAME IS NOT NULL  
        AND M.FULLCLASSNAME <> '') TB  
  
    /*IF NO ERRORS, COMMIT TRANSACTION*/  
    COMMIT TRANSACTION  
  END TRY  
  
  /*IF AN ERROR OCCURS*/  
  
  BEGIN CATCH  
  
    DECLARE @ERRORMESSAGE nvarchar(max),  
            @ERRORSEVERITY nvarchar(255),  
            @ERRORNUMBER nvarchar(50),  
            @ERRORSTATE nvarchar(255);  
  
    SELECT  
      @ERRORMESSAGE = ERROR_MESSAGE(),  
      @ERRORSEVERITY = ERROR_SEVERITY(),  
      @ERRORSTATE = ERROR_STATE();  
  
    /*UNDO THE TRANSACTION*/  
    IF @@TRANCOUNT > 0  
      ROLLBACK TRANSACTION;  
  
    DECLARE @MESSAGE varchar(max) =  
    'Merge Contact Failed: Error ' + CONVERT(varchar(50), ERROR_NUMBER()) +  
    ', Severity ' + CONVERT(varchar(5), ERROR_SEVERITY()) +  
    ', State ' + CONVERT(varchar(5), ERROR_STATE()) +  
    ', Procedure ' + ISNULL(ERROR_PROCEDURE(), '-') +  
    ', Line ' + CONVERT(varchar(5), ERROR_LINE()) +  
    ', Details: ' + ERROR_MESSAGE();  
  
  
    INSERT INTO [GLOBALERROR] ([GGLOBALERROR],  
    [USERNAME],  
    [LOGDATE],  
    [EXCEPTION],  
    [SENTTOENERGOV],  
    [GLOBALERRORNUMBER])  
      VALUES (LOWER(NEWID()), N'Merge Contact', GETDATE(), @message, NULL, CONVERT(varchar(20), (SELECT NEXTVALUE FROM AUTONUMBERSETTINGS WHERE CLASSNAME = 'EnerGovBusiness.SystemSetup.GlobalErrorMessages')) + '-' + CONVERT(varchar(25), GETDATE(), 105)  -- GLOBALERRORNUMBER - nvarchar(50)  
      );  
  
    SET @ERRORNUMBER = (SELECT  
      CONVERT(varchar(20), (SELECT  
        NEXTVALUE  
      FROM AUTONUMBERSETTINGS  
      WHERE CLASSNAME = 'EnerGovBusiness.SystemSetup.GlobalErrorMessages')  
      ) + '-' + CONVERT(varchar(25), GETDATE(), 105))  
    RAISERROR (@ERRORNUMBER, @ERRORSEVERITY, @ERRORSTATE);  
  
    /*INCREMENT ERROR NUMBER*/  
    UPDATE dbo.AUTONUMBERSETTINGS  
    SET NEXTVALUE = NEXTVALUE + 1  
    WHERE dbo.AutoNumberSettings.[CLASSNAME] = 'EnerGovBusiness.SystemSetup.GlobalErrorMessages'  
  END CATCH  
  
END